<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width; initial-scale = 1.0;" />
    <title>Caching in couchdb </title>
    <link href="../../style.css" rel="stylesheet"/>

    
  </head>
  <body>
    <header> 
  
  <nav>
    <ul>       
      <li><a href="/">staticshin</a></li>
      <li><a href="/about.html">about</a></li>
      <li><a href="/archives.html">archives</a></li>
      <li title="more" id="more-menu">[...]</li>
    </ul>
  </nav>
  <div class="grid grid-pad nav-grid" style="display:none">
      <div class="col-1-3">
	<h3>Popular Posts</h3>
        <ol>
          <li><a href="/knife-in-the-water">Knife in the water</a></li>
          <li><a href="/understanding-punctuation-in-erlang">Understanding punctuation in erlang</a></li>
          <li><a href="/absurdity-keeler-webwork-and-nis">Absurdity, Keeler, webwork and NIS </a></li>
          <li><a href="/rayman-origins-is-a-silly-little-game">Rayman origins is a silly little game</a></li>
          <li><a href="/dead-man">Dead man</a></li>
        </ol>
      </div>
      <div class="col-1-3">
	<h3>Also on staticshin</h3>
        <a href="/programming">Thoughts on programming</a>
      </div>
      <div class="col-1-3">
      </div>
    </div>
</header>

    <div class="grid grid-pad">
      <div class="col-8-12 push-2-12">
	<h1>Caching in couchdb </h1>
	<span>Akshat Jiwan Sharma,  Mon Oct 06 2014</span>
	<div class="postBody"><p>I remember reading a quote a while ago by someone somewhere that said something like </p>
<blockquote>
<p>There are only two hard things in Computer Science: compilers and cache invalidation.</p>
</blockquote>
<p>I might be off by one on this one, as I read this a long time ago, but I am pretty sure that one of the hard things was cache invalidation. </p>
<p>"How is this quote relevant to our discussion?"</p>
<p>Err... I thought I might put something up there since we will talking about caching in this article. To be more specific we will be talking about caching in couchdb. </p>
<h3>Let's start with something simple. A document.</h3>
<p>A document in couchdb is simply a json object. For example </p>
<pre><code>{
"name":"Rayman",
"roll_number":23

}</code></pre>
<p>When this object is saved in couchdb it adds two special fields to this document and it becomes: </p>
<pre><code>{
 "_id":12e4r75869098567,
 "_rev": 1-e234588769829,
 "name":"Rayman",
"roll_number":23

}</code></pre>
<p>These two special fields are the _id and the _rev fields. The _id field is a unique identifier for a document. As you might expect this has to be unique for every document in that is stored within couchdb. The <code>_rev</code> is the one which we are more  interested in at the moment.<code>_rev</code> field denotes a specific revision of couchdb document. What this means is that every time you update a document it's <code>_rev</code> field is updated as well. The old documents can still be accessed by querying with the old <code>_rev</code> id. This makes couchdb documents versioned. </p>
<p>"Cool. But what does this have to do with caching?" </p>
<p>when you query a couchdb document using the http api it will send in the <code>_rev</code> as an etag. This makes sense because the versioned content in a document is uniquely identified by it's <code>_rev</code> field. When a browser sends an <code>If-None-Match</code> header to couchdb it is matched against the current <code>_rev</code> of the document. If the header and the <code>_rev</code> fields are unchanged couchdb can safely send a 304--Not Modified status code to the browser. </p>
<p>So the document level caching in couchdb is handled by etags which are just the <code>_rev</code> field of the document. Pretty simple so far.  </p>
<h3>Views</h3>
<p>Things get a bit complicated with views. There are two important points to keep in mind here :-</p>
<ol>
<li><p>On disk the view indexes are stored  in a file which is named after md5 hash of the content of <strong>all</strong> the views in a design document. This means that if you change the content of any single view within a design document the index will have to be rebuilt. </p>
</li>
<li><p>The views are built and updated when you read from them. </p>
</li>
</ol>
<p>Now that we have a solid understanding of views we can understand how etags are generated. Etags in views are generated by taking the md5 hash of a unique signature. What makes up a signature. Well lots of things. Take a look at the following structure </p>
<pre><code>-record(mrargs, {
    view_type,
    reduce,

    preflight_fun,

    start_key,
    start_key_docid,
    end_key,
    end_key_docid,
    keys,

    direction = fwd,
    limit = 16#10000000,
    skip = 0,
    group_level = 0,
    stale = false,
    inclusive_end = true,
    include_docs = false,
    doc_options = [],
    update_seq=false,
    conflicts,
    callback,
    list,
    extra = []
}).</code></pre>
<p>This is an erlang record that makes up the gist of the view signature that is used to then generate an etag. As a whole the structure looks a bit daunting. But if we take a look at the fields one at a time most of them are recognizable. For instance:- </p>
<pre><code>start_key,
end_key,
start_key_docid,
end_key_docid
reduce,
include_docs=true,
keys,
limit,
skip,
group_level</code></pre>
<p>are simply the query parameters to the couchdb <code>view api</code>. So it's easy to deduce that one of the factors that makes up the signature are the query parameters to the view. This is easily verifiable. Simply query a view with different parameters and then inspect their etags. They will all be different. </p>
<p>The other important thing that makes up the signature is the update and purge seq of the database for which the view is being queried. The update and purge sequences can be checked by issuing a get request to your database. </p>
<p><strong>Conclusion</strong></p>
<p>Etag in a view depends upon the query parameters, the update sequence of the database and the purge seq of the database. If none of these three variables change the etag won't change and couchdb will issue a 304--Not-Modified header. </p>
<h3>Lists</h3>
<p>List functions are interesting because they can be used to process the result of views and push out the results in a format that is consumable by our client. What they do is they take in the result of view as an input -&gt; apply the transformation we want on that input and returns the result. So I think one would assume that the etags in the list depends upon the value etag of the view. One would be right to an extent. </p>
<p>The etags in the list function does indeed depend upon the signature of the underlying view. But there's more that it depends upon. Let me quote in a small section from the couchdb source code : - </p>
<pre><code> ETagFun = fun(BaseSig, Acc0) -&gt;

   UserCtx = Req#httpd.user_ctx,
   Name = UserCtx#user_ctx.name,
   Roles = UserCtx#user_ctx.roles,
   Accept = couch_httpd:header_value(Req, "Accept"),
   Parts = {couch_httpd:doc_etag(DDoc), Accept, {Name, Roles}},
   ETag = couch_httpd:make_etag({BaseSig, Parts}),
.......Rest of the function continued</code></pre>
<p>The etag function besides the base signature depends upon </p>
<ol>
<li>Name of the user</li>
<li>The roles of the user.</li>
<li>The accept header tag (this means that everything else being the same Accept JSON and Accept xml will have different etags )</li>
<li>The etag of the design doc. This can be seen in the Parts tuple (the first field)</li>
</ol>
<p><strong>Conclusion</strong></p>
<p>A resource from a list will be cached if the user name, the user roles, the accept header and the design document from which the list is being queried stays the same. This has two important implications. </p>
<p>a) It does not matter if the content returned by the list function is different. If the parameters that go into calculating the etag do not change the the etag won't change. Or your resource would be cached even if the content returned is different. </p>
<p>b) Since list functions can be called from different design document than the view the etag of list will also depend upon the etag of the design document.  </p>
<h3>Show</h3>
<p>If you have understood how the etags for the views and list are calculated then the show function is not too difficult to understand. I will quote the source:-</p>
<pre><code>couch_httpd:make_etag({couch_httpd:doc_etag(DDoc), DocPart, Accept,
        {UserCtx#user_ctx.name, UserCtx#user_ctx.roles}, More}).</code></pre>
<p>So the etag of the show function depends upon :-</p>
<ol>
<li>The etag of the design document.</li>
<li>The etag of the underlying document against which the show function is run</li>
<li>The user name and roles</li>
<li>More.. does not matter. I think this is kept for a future feature where the etag for show might depend upon more parameters :)</li>
</ol>
<p>So once more it does not really matter if the content returned by the show function is different from the content that originally generated the etag. All it cares is whether the four parameters changed or not.</p>
<h3>How to serve dynamic content from show and list functions then?</h3>
<p>As we have seen that list and show function do not calculate etag from the content of the response. So this makes them unsuitable for serving dynamic content to the browser. In these cases I usually generate my own etags that is an md5 hash of the original show/list etag +etag calculated from the content. This way if the content and the underlying etag does not change couchdb will send a 304 response but if any one of them changes 200 status code along with new etag will be sent. </p>
<p>For example:- </p>
<p>I have a show function that works on a given document called the <code>account</code>. This account document has a structure like so..</p>
<pre><code>
"base": "&lt;html&gt;....&lt;/html&gt;"
"rent_contract_template":"&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;"
"rent_summary_template": "&lt;h3&gt;&lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt;&lt;/h3&gt;"</code></pre>
<p>Don't mind the finer details. This account document simply holds the template strings. The base is the outer html where as the <code>rent_contract</code> and <code>rent_summary</code> are the html that will be appended after transforming them against a data set. Pretty standard stuff. My show function works against this account document. </p>
<p>But to this show function I also <code>post</code> the results from two list functions that serve as the data set against which the templates will be computed. So how do I maintain a etag for this dynamic scenario. As we already know that etag in show/list is not calculated by the content but from a set of predefined parameters. So I make my own etags. The ingredients:-</p>
<ol>
<li>The etag from the first list.</li>
<li>The etag from the second list </li>
<li>The etag from the show </li>
<li>Chemical X!</li>
</ol>
<p>are concatenated and it's md5 hash is calculated. I send the resultant string to the browser as the final etag. Now if the etag from any one of my input parameters i.e the list1,the list 2 or the show change the content returned by the template and hence the final etag would be different and I can serve dynamic cache-able content right from my show function. </p>
<p>That's it for this post folks. Want more?  <a href="http://blog.couchdb.org"> The official couchdb blog</a> is pretty cool. Also there is this silly post that illustrates how you can <a href="http://www.staticshin.com/programming/testing-couchapps-with-couchdb/">build CABS with couchdb</a>  </p>
<p><strong><a href="https://www.youtube.com/watch?v=QGnh0q4RuQ8">Mambo Italiano!</a></strong></p>
</div>
      </div>
    </div>
    <div id="disqus_thread"></div>
    <hr/>
    <footer>
      <h1>Thank you for reading</h1>
    </footer>
    <noscript>
      Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript>
<div>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'staticshin'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function ()
  {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37138783-1']);
  _gaq.push(['_trackPageview']);

  (function ()
  {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
<script src="../../staticshin.js"> </script>

</body>

</html>
