<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8"/>
    <meta name="referrer" content="no-referrer">
    <title>Mongodb and meteor</title>
    <link href="/study/index.css" rel="stylesheet"/>

  </head>
  <body>
    <ol>
      <li>We can start meteor with an external <a href="http://stackoverflow.com/questions/18545905/meteor-without-mongo">mongodb</a> and it won't start it's local mongodb instance </li>
      <li> How to pass a mongourl reference <a href="http://meteor.hromnik.com/blog/meteor-run-without-creating-local-mongo-database">to the command line</a>
        <small>[ we probably won't need to do this because reaction config <a href="/study/ecommerce.html#database_url">file</a> will take care of this for us</small>
      </li>
    </ol>
    <div id="proxy_pool">
      <h1>Proxy based connection pooling with mongodb</h1>
      <p>
       Proxying a tcp server with nginx causes the client to create a <a href="/activity-logs/index.html#m_p_pool">new connection</a> with the server. This is fine if the connections are few and short lived. But can get a bit unmanageable hand if we're talking about lots of long lived connections. Moreover the entire purpose of using a proxy is to shield our server from an unexpected spike/ minimize the traffic it has to serve so that it can simply do it's job and the request/response is handled by the proxy.  
      </p>
      <p>In an ideal case nginx should handle the incoming client connections and a tcp server like mongodb should reply only the requests of nginx. So the communications flows like this:-</p>
      <ul>
          <li>Client connects with nginx</li>
          <li>nginx connects with mongodb</li>
          <li>Client requests info from mongodb server</li>
          <li>nginx intercepts that request and passes it through the socket that is connected with mongo db</li>
          <li>Mongo db responds to the same socket</li>
          <li>And nginx relays that response to the client</li>
      </ul>
      <p>
	Such a channel can't be established with plain nginx it seems.
	But there is an <a href="https://github.com/openresty/stream-lua-nginx-module">openresty module</a>
	that allows us "inject" lua code into tcp streams.
	In terms of openresty we can implement our plan like this :- 
      </p>
      <ol>
          <li>Create a stream server that listens to incoming requests. The clients will connect to this server.</li>
          <li>Create a socket to mongodb.</li>
          <li>Intercept client requests and forward it to mongodb using the connection created in #2</li>
          <li>Read the mongodb response and relay it to the client </li>
          <li>Keep the client connection alive so that it does not have to deal with connection management issues.</li>
      </ol>
      <p>All of this sounds complex but is should be very easy to implement. Also since we are dealing with nginx here we can implement our changes in a running system by making effective use of proxy. So that the clients that are already connected to mongodb won't even notice if anything changed at all. </p>
    </div>
    <p><small>-- <a href="/about.html">Akshat Jiwan Sharma</a></small></p>     

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-37138783-1']);
      _gaq.push(['_trackPageview']);

      (function ()
      {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    <script src="/jquery-1.11.1.min.js" type="text/javascript"></script>
    <script src="/study/index.js" type="text/javascript"></script>

  </body>
</html>
